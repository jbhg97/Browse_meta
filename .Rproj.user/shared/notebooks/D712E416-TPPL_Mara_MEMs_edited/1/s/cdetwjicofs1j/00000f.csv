"0",""
"0","# There are some functions needed to run this code"
"0","# Plot obtained from: GitHub- JoeyBernhardt/NumericalEcology/sr.value.R"
"0",""
"0","sr.value <- function (dfxy, z, xax = 1, yax = 2, method = c(""bubble"","
"0","                                                            ""greylevel""), zmax = NULL, csize = 1, cpoint = 0, pch = 20,"
"0","                      clegend = 0.75, neig = NULL, cneig = 1, xlim = NULL, ylim = NULL,"
"0","                      grid = TRUE, addaxes = TRUE, cgrid = 0.75, include.origin = TRUE,"
"0","                      origin = c(0, 0), sub = """", csub = 1, possub = ""topleft"","
"0","                      pixmap = NULL, contour = NULL, area = NULL, add.plot = FALSE)"
"0","  #"
"0","  # Slightly modified version of ade4's s.value() graphical function."
"0","  # Draws round instead of square bubbles in some plots when argument "
"0","  # ""bubble"" is called."
"0","  #"
"0","  # License: GPL-2"
"0","  # Author of the original function s.value: Daniel Chessel"
"0","  # Modification: Francois Gillet, 25 August 2012"
"0","  #"
"0","{"
"0","  dfxy <- data.frame(dfxy)"
"0","  if (length(z) != nrow(dfxy))"
"0","    stop(paste(""Non equal row numbers"", nrow(dfxy), length(z)))"
"0","  opar <- par(mar = par(""mar""))"
"0","  on.exit(par(opar))"
"0","  par(mar = c(0.1, 0.1, 0.1, 0.1))"
"0","  coo <- scatterutil.base(dfxy = dfxy, xax = xax, yax = yax,"
"0","                          xlim = xlim, ylim = ylim, grid = grid, addaxes = addaxes,"
"0","                          cgrid = cgrid, include.origin = include.origin, origin = origin,"
"0","                          sub = sub, csub = csub, possub = possub, pixmap = pixmap,"
"0","                          contour = contour, area = area, add.plot = add.plot)"
"0","  if (!is.null(neig))"
"0","  {"
"0","    if (is.null(class(neig))) neig <- NULL"
"0","    if (class(neig) != ""neig"") neig <- NULL"
"0","    deg <- attr(neig, ""degrees"")"
"0","    if (length(deg) != length(coo$x)) neig <- NULL"
"0","  }"
"0","  if (!is.null(neig))"
"0","  {"
"0","    fun <- function(x, coo)"
"0","    {"
"0","      segments(coo$x[x[1]], coo$y[x[1]], coo$x[x[2]], coo$y[x[2]],"
"0","               lwd = par(""lwd"") * cneig)"
"0","    }"
"0","    apply(unclass(neig), 1, fun, coo = coo)"
"0","  }"
"0","  method <- method[1]"
"0","  if (method == ""greylevel"")"
"0","  {"
"0","    br0 <- pretty(z, 6)"
"0","    nborn <- length(br0)"
"0","    coeff <- diff(par(""usr"")[1:2])/15"
"0","    numclass <- cut.default(z, br0, include = TRUE, lab = FALSE)"
"0","    valgris <- seq(1, 0, le = (nborn - 1))"
"0","    h <- csize * coeff"
"0","    for (i in 1:(nrow(dfxy)))"
"0","    {"
"0","      symbols(coo$x[i], coo$y[i], circles = h/2, "
"0","              bg = gray(valgris[numclass[i]]),"
"0","              add = TRUE, inch = FALSE)"
"0","    }"
"0","    scatterutil.legend.circle.grey(br0, valgris, h/2, clegend)"
"0","    if (cpoint > 0) points(coo$x, coo$y, pch = pch, cex = par(""cex"") * cpoint)"
"0","  }"
"0","  else if (method == ""bubble"")"
"0","  {"
"0","    coeff <- diff(par(""usr"")[1:2])/15"
"0","    sq <- sqrt(abs(z))"
"0","    if (is.null(zmax)) zmax <- max(abs(z))"
"0","    w1 <- sqrt(zmax)"
"0","    sq <- csize * coeff * sq/w1"
"0","    for (i in 1:(nrow(dfxy)))"
"0","    {"
"0","      if (sign(z[i]) >= 0)"
"0","      {"
"0","        symbols(coo$x[i], coo$y[i], circles = sq[i]/2, bg = ""black"", "
"0","                fg = ""white"", add = TRUE, inch = FALSE)"
"0","      }"
"0","      else"
"0","      {"
"0","        symbols(coo$x[i], coo$y[i], circles = sq[i]/2, bg = ""white"", "
"0","                fg = ""black"", add = TRUE, inch = FALSE)"
"0","      }"
"0","    }"
"0","    br0 <- pretty(z, 4)"
"0","    l0 <- length(br0)"
"0","    br0 <- (br0[1:(l0 - 1)] + br0[2:l0])/2"
"0","    sq0 <- sqrt(abs(br0))"
"0","    sq0 <- csize * coeff * sq0/w1"
"0","    sig0 <- sign(br0)"
"0","    if (clegend > 0) scatterutil.legend.bw.circle(br0, sq0, sig0, clegend)"
"0","    if (cpoint > 0) points(coo$x, coo$y, pch = pch, cex = par(""cex"") * cpoint)"
"0","  }"
"0","  else if (method == ""circlesize"") print(""not yet implemented"")"
"0","  if (!add.plot) box()"
"0","  invisible(match.call())"
"0","}"
"0",""
"0",""
"0",""
"0","scatterutil.legend.bw.circle <- function (br0, sq0, sig0, clegend)"
"0","{"
"0","  br0 <- round(br0, dig = 6)"
"0","  cha <- as.character(br0[1])"
"0","  for (i in (2:(length(br0)))) cha <- paste(cha, br0[i], sep = "" "")"
"0","  cex0 <- par(""cex"") * clegend"
"0","  yh <- max(c(strheight(cha, cex = cex0), sq0))"
"0","  h <- strheight(cha, cex = cex0)"
"0","  y0 <- par(""usr"")[3] + yh/2 + h/2"
"0","  ltot <- strwidth(cha, cex = cex0) + sum(sq0) + h"
"0","  rect(par(""usr"")[1] + h/4, y0 - yh/2 - h/4, "
"0","       par(""usr"")[1] + ltot + h/4, y0 + yh/2 + h/4, col = ""white"")"
"0","  x0 <- par(""usr"")[1] + h/2"
"0","  for (i in (1:(length(sq0))))"
"0","  {"
"0","    cha <- br0[i]"
"0","    cha <- paste("" "", cha, sep = """")"
"0","    xh <- strwidth(cha, cex = cex0)"
"0","    text(x0 + xh/2, y0, cha, cex = cex0)"
"0","    z0 <- sq0[i]"
"0","    x0 <- x0 + xh + z0/2"
"0","    if (sig0[i] >= 0)"
"0","      symbols(x0, y0, circles = z0/2, bg = ""black"", fg = ""white"","
"0","              add = TRUE, inch = FALSE)"
"0","    else symbols(x0, y0, circles = z0/2, bg = ""white"", fg = ""black"","
"0","                 add = TRUE, inch = FALSE)"
"0","    x0 <- x0 + z0/2"
"0","  }"
"0","  invisible()"
"0","}"
"0",""
"0",""
"0",""
"0","scatterutil.legend.circle.grey <- function (br0, valgris, h, clegend)"
"0","{"
"0","  if (clegend <= 0) return(invisible())"
"0","  br0 <- round(br0, dig = 6)"
"0","  nborn <- length(br0)"
"0","  cex0 <- par(""cex"") * clegend"
"0","  x0 <- par(""usr"")[1] + h"
"0","  x1 <- x0"
"0","  for (i in (2:(nborn)))"
"0","  {"
"0","    x1 <- x1 + h"
"0","    cha <- br0[i]"
"0","    cha <- paste(cha, ""]"", sep = """")"
"0","    xh <- strwidth(cha, cex = cex0)"
"0","    if (i == (nborn)) break"
"0","    x1 <- x1 + xh + h"
"0","  }"
"0","  yh <- max(strheight(paste(br0), cex = cex0), h)"
"0","  y0 <- par(""usr"")[3] + yh/2 + h/2"
"0","  rect(par(""usr"")[1] + h/4, y0 - yh/2 - h/4, x1 - h/4, y0 + yh/2 + h/4, "
"0","       col = ""white"")"
"0","  x0 <- par(""usr"")[1] + h"
"0","  for (i in (2:(nborn)))"
"0","  {"
"0","    symbols(x0, y0, circles = h/2, bg = gray(valgris[i - 1]), add = TRUE, "
"0","            inch = FALSE)"
"0","    x0 <- x0 + h"
"0","    cha <- br0[i]"
"0","    if (cha < 1e-05) cha <- round(cha, dig = 3)"
"0","    cha <- paste(cha, ""]"", sep = """")"
"0","    xh <- strwidth(cha, cex = cex0)"
"0","    if (i == (nborn)) break"
"0","    text(x0 + xh/2, y0, cha, cex = cex0)"
"0","    x0 <- x0 + xh + h"
"0","  }"
"0","  invisible()"
"0","}"
"0",""
"0",""
"0",""
"0","##create scalog"
"0","scalog <- function(res, np = 999, alpha = c(0.05, 0.01, 0.001), cex=2)"
"0","{"
"0","  "
"0","  # A function to compute a scalogram (Legendre and Legendre 2012, "
"0","  # p. 864) representing the eigenvalues of an RDA with a series of "
"0","  # spatial eigenfunctions (e.g. dbMEM) as explanatory variables."
"0","  # The eigenfunctions must be placed in decreasing order and they"
"0","  # must be orthogonal to one another."
"0","  # In case of RDA the R^2 is variance, in case of CCA it is inertia."
"0","  "
"0","  # Arguments"
"0","  "
"0","  # res    An RDA or CCA result object produced by vegan::rda()."
"0","  #        The RDA or CCA must have been computed with the formula"
"0","  #        interface."
"0","  # np     number of permutations in the RDA test"
"0","  # alpha  probability thresholds for the color coding"
"0","  "
"0","  # License: GPL-2 "
"0","  # Author: Daniel Borcard, 2017"
"0","  "
"0","  test <- anova(res, by = ""terms"", permutations = how(nperm = np))"
"0","  inert <- test[,2]"
"0","  variance <- inert[-length(inert)] / sum(inert)"
"0","  signi <- test$""Pr(>F)""[-length(test$""Pr(>F)"")]"
"0","  n <- length(variance)"
"0","  "
"0","  if(class(res)[1] == ""rda"") "
"0","    ylabel <- expression(italic(R)^{2})"
"0","  else"
"0","    ylabel <- ""Inertia"""
"0","  "
"0","  plot("
"0","    1 : n, "
"0","    variance, "
"0","    type = ""n"", "
"0","    main = ""Scalogram"", "
"0","    xlab = ""Eigenfunction number"", "
"0","    ylab = ylabel"
"0","  )"
"0","  lines(1 : n, variance)"
"0","  alpha <- c(1, sort(alpha, decreasing = TRUE))"
"0","  colour <- c(""white"", ""greenyellow"", ""orange"", ""red"")"
"0","  for(i in 1 : 4)"
"0","  {"
"0","    points("
"0","      (1 : n)[signi <= alpha[i]], "
"0","      variance[signi <= alpha[i]], "
"0","      pch = 22, "
"0","      cex = cex,"
"0","      bg = colour[i]"
"0","    )"
"0","  }"
"0","  legend("
"0","    ""topright"","
"0","    fill = c(""red"", ""orange"", ""greenyellow""),"
"0","    legend = c(paste(""p <= "", alpha[4]), paste(""p <= "", alpha[3]), "
"0","               paste(""p <= "", alpha[2]))"
"0","  )"
"0","  invisible(test)"
"0","}"
"0","#' Function to compute and test eigenvectors of spatial weighting matrices"
"0","#' "
"0","#' This function is now deprecated. Please try the new \code{\link{listw.candidates}} and "
"0","#' \code{\link{listw.select}} functions."
"0","#' "
"0","#' This function is a user-friendly way to compute and test eigenvectors for"
"0","#' various definitions of spatial weighting matrices. It combines calls to the "
"0","#' functions \code{scores.listw} and \code{ortho.AIC}. It allows to test various"
"0","#' definitions of the spatial weighting matrix and return results of "
"0","#' \code{scores.listw} for the best one."
"0","#' "
"0","#' @details This functions allows to test one binary spatial weighting matrix "
"0","#'   (if only Y and nb are provided). It allows also to test a weighting "
"0","#'   function based on distances (if f is provided) and a weighting function "
"0","#'   with different values of parameters if other arguments of \code{f} are "
"0","#'   provided."
"0","#'   "
"0","#' @param Y A matrix with response variables (univariate or multivariate "
"0","#'   response)"
"0","#' @param nb An object of the class \code{nb} created by functions of the "
"0","#'   \code{spdep} package"
"0","#' @param xy Coordinates of the samples, this argument is optional and is "
"0","#'   required only if the argument \code{f} is not null."
"0","#' @param MEM.autocor A string indicating if all MEM must be returned or only "
"0","#'   those corresponding to positive or negative autocorrelation"
"0","#' @param f A function of the distance that can be used as a weighting spatial "
"0","#'   function. This argument is optional"
"0","#' @param \dots Others arguments for the function \code{f}. It defines the range"
"0","#'   of parameters which will be tested"
"0","#' @return A list with the following elements: \item{all }{A data.frame where "
"0","#'   each row correspond to one spatial weighting matrix tested. It contains "
"0","#'   value of parameteres tested and corrected AIC and number of orthogonal "
"0","#'   vectors for the best model.} \item{best }{A list containing results of "
"0","#'   scores.listw and ortho.AIC of the best spatial weighting matrix according "
"0","#'   to corrected AIC.}"
"0","#' @author Stéphane Dray \email{stephane.dray@@univ-lyon1.fr}"
"0","#' @seealso   \code{\link{ortho.AIC}}, \code{\link{scores.listw}}"
"0","#' @references Dray S., Legendre P. and Peres-Neto P. R. (2006) Spatial "
"0","#'   modeling: a comprehensive framework for principal coordinate analysis of "
"0","#'   neighbor matrices (PCNM). Ecological Modelling, 196, 483--493"
"0","#' @keywords spatial"
"0","#' @examples"
"0","#' "
"0","#' if(require(ade4) & require(spdep)){"
"0","#' "
"0","#' data(oribatid)"
"0","#' # Hellinger transformation"
"0","#' fau <- sqrt(oribatid$fau / outer(apply(oribatid$fau, 1, sum), rep(1, ncol(oribatid$fau)), ""*""))"
"0","#' # remove gradient effect"
"0","#' faudt <- resid(lm(as.matrix(fau) ~ as.matrix(oribatid$xy)))"
"0","#' "
"0","#' # test a binary spatial weighting matrix"
"0","#' nbtri <- tri2nb(as.matrix(oribatid$xy))"
"0","#' tri.res <- test.W(faudt, nbtri)"
"0","#' "
"0","#' maxi <- max(unlist(nbdists(nbtri, as.matrix(oribatid$xy))))"
"0","#' "
"0","#' # test a simple spatial weighting function of the distance"
"0","#' f1 <- function(x) {1-(x)/(maxi)}"
"0","#' tri.f1 <- test.W(faudt, nbtri, f = f1, xy = as.matrix(oribatid$xy))"
"0","#' "
"0","#' # test a spatial weighting function with various values of parameters"
"0","#' f2 <- function(x,dmax,y) {1-(x^y)/(dmax)^y}"
"0","#' tri.f2 <- test.W(faudt,nbtri, f = f2, y = 2:10, dmax = maxi, xy = as.matrix(oribatid$xy))"
"0","#' }"
"0","#' "
"0","#' @importFrom spdep nb2listw"
"0","#' @export"
"0","#' "
"0","""test.W"" <-"
"0","  function(Y,"
"0","           nb,"
"0","           xy,"
"0","           MEM.autocor = c(""all"", ""positive"", ""negative""),"
"0","           f = NULL,"
"0","           ...) {"
"0","    .Deprecated(new = ""listw.select"", package = ""adespatial"", "
"0","                msg = ""This function is now deprecated. Please try the new 'listw.select' function."")"
"0","    "
"0","    mycall <- pairlist(...)"
"0","    res <- list()"
"0","    MEM.autocor <- match.arg(MEM.autocor)"
"0","    if (!(is.null(f))) {"
"0","      nbdist <- nbdists(nb, as.matrix(xy))"
"0","      if (!(is.null(mycall))) {"
"0","        param <- expand.grid(as.list(mycall))"
"0","        m1 <- match(names(param), names(formals(f)))"
"0","        for (i in 1:nrow(param)) {"
"0","          formals(f)[m1] <- unclass(param[i,])"
"0","          res[[i]] <-"
"0","            scores.listw(nb2listw("
"0","              nb,"
"0","              style = ""B"","
"0","              glist = lapply(nbdist, f), "
"0","              zero.policy = TRUE"
"0","            ),"
"0","            MEM.autocor = MEM.autocor)"
"0","        }"
"0","      }"
"0","      else {"
"0","        res[[1]] <-"
"0","          scores.listw(nb2listw(nb, style = ""B"", glist = lapply(nbdist, f)),"
"0","                       MEM.autocor = MEM.autocor)"
"0","      }"
"0","    }"
"0","    else {"
"0","      res[[1]] <-"
"0","        scores.listw(nb2listw(nb, style = ""B""), MEM.autocor = MEM.autocor)"
"0","    }"
"0","    res2 <-"
"0","      lapply(res, function(x)"
"0","        ortho.AIC("
"0","          Y = Y,"
"0","          X = x,"
"0","          ord.var = TRUE"
"0","        ))"
"0","    if (!(is.null(mycall))) {"
"0","      res3 <-"
"0","        data.frame(AICc = unlist(lapply(res2, function(x)"
"0","          min(x[[1]], na.rm = TRUE))), NbVar = unlist(lapply(res2, function(x)"
"0","            which.min(x[[1]]))))"
"0","      res3 <- cbind(param, res3)"
"0","    }"
"0","    else{"
"0","      res3 <-"
"0","        data.frame(AICc = unlist(lapply(res2, function(x)"
"0","          min(x[[1]], na.rm = TRUE))), NbVar = unlist(lapply(res2, function(x)"
"0","            which.min(x[[1]]))))"
"0","    }"
"0","    "
"0","    thebest <- which.min(res3$AICc)"
"0","    cat (paste(""\n\nAICc for the null model:"", res2[[thebest]]$AICc0, ""\n""))"
"0","    cat (""\nBest spatial model:\n"")"
"0","    print(res3[thebest,])"
"0","    "
"0","    return(list(all = res3, best = list(MEM = res[[thebest]], AIC = res2[[thebest]])))"
"0","    "
"0","  }"
"0","scalog <- function(res, np = 999, alpha = c(0.05, 0.01, 0.001), cex=2)"
"0","{"
"0",""
"0","# A function to compute a scalogram (Legendre and Legendre 2012, "
"0","# p. 864) representing the eigenvalues of an RDA with a series of "
"0","# spatial eigenfunctions (e.g. dbMEM) as explanatory variables."
"0","# The eigenfunctions must be placed in decreasing order and they"
"0","# must be orthogonal to one another."
"0","# In case of RDA the R^2 is variance, in case of CCA it is inertia."
"0",""
"0","# Arguments"
"0",""
"0","# res    An RDA or CCA result object produced by vegan::rda()."
"0","#        The RDA or CCA must have been computed with the formula"
"0","#        interface."
"0","# np     number of permutations in the RDA test"
"0","# alpha  probability thresholds for the color coding"
"0",""
"0","# License: GPL-2 "
"0","# Author: Daniel Borcard, 2017"
"0",""
"0","test <- anova(res, by = ""terms"", permutations = how(nperm = np))"
"0","inert <- test[,2]"
"0","variance <- inert[-length(inert)] / sum(inert)"
"0","signi <- test$""Pr(>F)""[-length(test$""Pr(>F)"")]"
"0","n <- length(variance)"
"0",""
"0","if(class(res)[1] == ""rda"") "
"0","  ylabel <- expression(italic(R)^{2})"
"0","else"
"0","  ylabel <- ""Inertia"""
"0","   "
"0","plot("
"0","  1 : n, "
"0","  variance, "
"0","  type = ""n"", "
"0","  main = ""Scalogram"", "
"0","  xlab = ""Eigenfunction number"", "
"0","  ylab = ylabel"
"0",")"
"0","lines(1 : n, variance)"
"0","alpha <- c(1, sort(alpha, decreasing = TRUE))"
"0","colour <- c(""white"", ""greenyellow"", ""orange"", ""red"")"
"0","for(i in 1 : 4)"
"0","{"
"0","  points("
"0","    (1 : n)[signi <= alpha[i]], "
"0","    variance[signi <= alpha[i]], "
"0","    pch = 22, "
"0","    cex = cex,"
"0","    bg = colour[i]"
"0","  )"
"0","}"
"0","legend("
"0","  ""topright"","
"0","  fill = c(""red"", ""orange"", ""greenyellow""),"
"0","  legend = c(paste(""p <= "", alpha[4]), paste(""p <= "", alpha[3]), "
"0","             paste(""p <= "", alpha[2]))"
"0",")"
"0","invisible(test)"
"0","}"
"0",""
"0",""
